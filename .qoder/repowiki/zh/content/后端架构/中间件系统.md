# 中间件系统

<cite>
**本文档引用的文件**   
- [auth.ts](file://backend/src/middleware/auth.ts)
- [apiKey.ts](file://backend/src/middleware/apiKey.ts)
- [errorHandler.ts](file://backend/src/middleware/errorHandler.ts)
- [logger.ts](file://backend/src/utils/logger.ts)
</cite>

## 目录
1. [JWT令牌验证逻辑](#jwt令牌验证逻辑)
2. [API密钥校验机制](#api密钥校验机制)
3. [错误处理机制](#错误处理机制)
4. [日志记录功能](#日志记录功能)
5. [中间件执行顺序](#中间件执行顺序)
6. [自定义中间件开发指南](#自定义中间件开发指南)

## JWT令牌验证逻辑

`auth.ts` 文件中实现了基于JWT（JSON Web Token）的身份验证中间件，主要包含 `authMiddleware`、`optionalAuthMiddleware`、`requireRole`、`requireAdmin` 和 `requireOwnerOrAdmin` 等函数。`authMiddleware` 是核心的身份验证中间件，其工作流程如下：首先检查请求头中的 `Authorization` 字段，若不存在则返回401状态码和“缺少访问令牌”错误。若存在，则提取Bearer令牌，并使用 `jwt.verify` 方法进行验证，验证密钥来自环境变量 `JWT_SECRET` 或默认密钥。验证成功后，将解码得到的用户ID和邮箱信息注入到 `req.user` 对象中，并调用 `next()` 进入下一个中间件。如果JWT验证失败（如令牌过期），则捕获 `JsonWebTokenError` 并返回401状态码和“令牌已过期或无效”错误。整个过程被包裹在try-catch块中，以捕获任何意外错误并返回500状态码。

此外，`optionalAuthMiddleware` 提供了可选的身份验证，当令牌不存在或无效时，不会中断请求流程，而是继续执行后续中间件。`requireRole` 函数是一个高阶函数，用于创建需要特定角色的中间件，它检查 `req.user` 是否存在，然后检查用户角色是否在允许的角色列表中，若不满足则返回403状态码。`requireAdmin` 是 `requireRole(['admin', 'superadmin'])` 的快捷方式。`requireOwnerOrAdmin` 用于实现资源所有者或管理员才能访问的权限控制，它检查当前用户ID是否与请求参数中的 `userId` 匹配，或者用户是否为管理员。

**Section sources**
- [auth.ts](file://backend/src/middleware/auth.ts#L10-L58)
- [auth.ts](file://backend/src/middleware/auth.ts#L100-L166)

## API密钥校验机制

`apiKey.ts` 文件中定义了API密钥的校验机制，核心函数为 `validateApiKey` 和 `validateAdminApiKey`。`validateApiKey` 中间件从请求头 `x-api-key` 中提取API密钥。如果密钥不存在，则返回401状态码和“缺少API密钥”错误。系统维护一个有效的API密钥列表，该列表由环境变量 `API_KEY_1`、`API_KEY_2` 和 `ADMIN_API_KEY` 构成，若提供的密钥不在该列表中，则返回401状态码和“无效的API密钥”错误。验证通过后，会记录密钥使用情况并调用 `next()`。

`validateAdminApiKey` 是一个更严格的中间件，专门用于验证管理员API密钥。它要求密钥必须与 `ADMIN_API_KEY` 环境变量的值完全匹配，否则返回403状态码和“需要管理员API密钥”错误。此机制确保了只有持有特定管理员密钥的请求才能访问敏感接口。

此外，文件还实现了基于API密钥的速率限制功能 `apiKeyRateLimit`。该函数返回一个中间件，使用一个 `Map` 来跟踪每个API密钥的请求次数和重置时间。它维护一个60秒的滑动窗口，对于每个请求，检查该密钥在当前窗口内的请求数。如果超过预设的限制（默认60次/分钟），则返回429状态码和“请求频率超限”错误。否则，增加计数并设置响应头 `X-RateLimit-Limit`、`X-RateLimit-Remaining` 和 `X-RateLimit-Reset` 以告知客户端其配额使用情况。

**Section sources**
- [apiKey.ts](file://backend/src/middleware/apiKey.ts#L3-L39)
- [apiKey.ts](file://backend/src/middleware/apiKey.ts#L42-L72)
- [apiKey.ts](file://backend/src/middleware/apiKey.ts#L75-L130)

## 错误处理机制

`errorHandler.ts` 文件实现了全局的错误处理机制，核心是 `errorHandler` 中间件。该中间件捕获所有未处理的异常，并生成标准化的错误响应。当错误发生时，首先在控制台记录详细的错误信息，包括错误消息、堆栈跟踪、请求URL、方法、IP地址等。

错误响应的构建过程如下：根据错误的类型（`error.name`）来确定HTTP状态码和错误代码。例如，`ValidationError` 对应400状态码和 `VALIDATION_ERROR` 错误码，`UnauthorizedError` 或 `JsonWebTokenError` 对应401状态码和 `UNAUTHORIZED` 错误码，以此类推。响应体包含 `success: false`、错误消息、错误代码、时间戳、请求路径和方法等信息。在开发环境下，还会包含堆栈跟踪和详细错误信息以方便调试；在生产环境下则隐藏这些敏感信息。

为了方便开发者抛出标准化错误，文件定义了 `CustomError` 基类和一系列具体的错误类，如 `ValidationError`、`UnauthorizedError`、`ForbiddenError` 等。这些类继承自 `CustomError`，并预设了相应的状态码。`asyncHandler` 函数是一个高阶函数，用于包装异步路由处理函数，它将 `Promise` 的 `reject` 状态自动传递给 `next()` 函数，从而被全局错误处理器捕获，避免了在每个异步函数中手动编写 `try-catch` 块。

**Section sources**
- [errorHandler.ts](file://backend/src/middleware/errorHandler.ts#L8-L85)
- [errorHandler.ts](file://backend/src/middleware/errorHandler.ts#L103-L158)

## 日志记录功能

`logger.ts` 文件利用 `winston` 库实现了强大的日志记录功能。它根据环境（开发/生产）配置了不同的日志级别、格式和传输器（transports）。在开发环境中，日志会输出到控制台并带有颜色，同时也会写入 `combined.log` 和 `error.log` 文件。在生产环境中，日志以结构化的JSON格式写入多个文件（`error.log`、`warn.log`、`combined.log`），便于日志分析系统处理。

核心的日志记录器 `logger` 被导出供全局使用。此外，文件还定义了 `httpLogger` 中间件，用于记录HTTP请求的详细信息。该中间件在请求开始时记录时间戳，并在响应结束时（`res.on('finish')`）计算请求耗时，并记录请求方法、URL、状态码、耗时、IP地址和用户代理等信息。根据响应状态码，日志级别会有所不同：400及以上状态码使用 `warn` 级别，其他使用 `http` 级别。

文件还提供了一个 `BusinessLogger` 类，用于记录业务相关的特定日志，如交易、KYC、区块链操作、安全事件和性能指标。这些日志会被分类并以结构化的方式记录，便于后续的审计和监控。

**Section sources**
- [logger.ts](file://backend/src/utils/logger.ts#L86-L92)
- [logger.ts](file://backend/src/utils/logger.ts#L102-L125)
- [logger.ts](file://backend/src/utils/logger.ts#L128-L195)

## 中间件执行顺序

中间件在Express应用的请求处理管道中按特定顺序执行。典型的执行顺序如下：
1.  **日志中间件 (`httpLogger`)**：最先执行，用于记录所有进入的请求，无论其后续结果如何。
2.  **身份验证中间件**：在日志之后，对需要身份验证的路由进行处理。
    *   `authMiddleware` 或 `optionalAuthMiddleware`：验证JWT令牌。
    *   `validateApiKey` 或 `validateAdminApiKey`：验证API密钥。
3.  **授权中间件**：在身份验证成功后，检查用户权限。
    *   `requireRole` / `requireAdmin`：检查用户角色。
    *   `requireOwnerOrAdmin`：检查资源所有权。
4.  **业务逻辑中间件/路由处理函数**：执行具体的业务逻辑。
5.  **错误处理中间件 (`errorHandler`)**：作为最后一个中间件，捕获并处理前面所有中间件和路由处理函数抛出的错误。
6.  **404处理中间件 (`notFoundHandler`)**：如果请求的路由未被任何路由处理函数匹配，则调用此中间件，它会抛出一个404错误，该错误随后被 `errorHandler` 捕获。

这种顺序确保了请求首先被记录，然后经过安全检查（认证和授权），最后才执行业务逻辑。任何环节的错误都会被统一的错误处理器捕获，保证了响应的一致性。

## 自定义中间件开发指南

开发自定义中间件时，应遵循以下指南：
1.  **函数签名**：中间件函数必须接受 `(req: Request, res: Response, next: NextFunction)` 三个参数。
2.  **调用 `next()`**：在完成其逻辑后，必须调用 `next()` 函数以将控制权传递给管道中的下一个中间件。如果不调用 `next()`，请求将被挂起。
3.  **错误处理**：如果中间件内部发生错误，应使用 `next(error)` 将错误传递给错误处理中间件，而不是直接发送响应（除非是最终的错误响应）。
4.  **使用 `asyncHandler`**：对于异步中间件，建议使用 `asyncHandler` 高阶函数进行包装，它可以自动处理Promise的拒绝状态，避免遗漏错误处理。
5.  **模块化和复用**：将通用逻辑（如权限检查）封装成可复用的中间件函数，例如 `requireRole` 的实现方式。
6.  **集成**：在应用的主文件（如 `index.ts`）中，使用 `app.use()` 方法按所需顺序注册中间件。例如，`app.use(httpLogger)` 应放在最前面，`app.use(errorHandler)` 应放在所有路由定义之后。

通过遵循这些指南，可以创建出健壮、可维护且易于集成的自定义中间件。